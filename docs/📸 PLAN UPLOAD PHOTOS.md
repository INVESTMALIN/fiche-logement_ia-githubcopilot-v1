# üì∏ PLAN UPLOAD PHOTOS - Architecture Compl√®te

## üéØ **OBJECTIF**
Int√©grer l'upload fonctionnel dans le process d'ajout de sections avec migration transparente Supabase ‚Üí Google Drive.

---

## üèóÔ∏è **ARCHITECTURE PROPOS√âE**

### **Option 1 : Supabase Storage (Phase 1 - Impl√©mentation imm√©diate)**
R√âSUM√â de l'approche intelligente :

1. Interface commune ‚Üí M√™me code pour Supabase ET Google Drive
2. Provider switching ‚Üí 1 variable d'environnement pour changer
3. Composants r√©utilisables ‚Üí M√™me PhotoUpload partout
4. Migration transparente ‚Üí Aucun code m√©tier √† modifier

PLAN D'ACTION :

Phase 1 (2h) :
- Setup Supabase Storage bucket
- Cr√©er l'interface + provider Supabase
- Composant PhotoUpload basique

Phase 2 (1h) :
- Int√©grer dans sections existantes (Gestion Linge + √âquipements)
- Tester upload/suppression

Phase 3 (Future) :
- Cr√©er googleDriveProvider.js
- Changer 1 variable d'environnement
- MIGRATION TERMIN√âE !

---

## üìÅ **STRUCTURE GOOGLE DRIVE (Future)**

### **Arborescence Automatique**
```
üìÅ Fiche-Logement-Photos/ (Dossier racine)
‚îú‚îÄ‚îÄ üìÅ fiche-001-villa-marseille/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ gestion-linge/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ photos-linge/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ linge_1640995200_IMG001.jpg
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üì∑ linge_1640995230_IMG002.jpg
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÅ emplacement-stock/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ üì∑ stock_1640995300_IMG003.jpg
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ üì∑ stock_1640995330_IMG004.jpg
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ equipements/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ local-poubelle/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üì∑ poubelle_1640995400_IMG005.jpg
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üì∑ poubelle_1640995430_IMG006.jpg
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ disjoncteur/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ vanne-eau/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÅ systeme-chauffage/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ clefs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ interphone/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ digicode/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÅ tempo-gache/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ autres-sections.../
‚îú‚îÄ‚îÄ üìÅ fiche-002-appartement-paris/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ ... (m√™me structure)
‚îî‚îÄ‚îÄ üìÅ fiche-003-studio-lyon/
    ‚îî‚îÄ‚îÄ üìÅ ... (m√™me structure)
```

### **Logique de Nommage Automatique**
```javascript
// Pattern : fiche-{id}-{nom-nettoye}/section/sous-dossier/
const generatePath = (ficheId, nomFiche, fieldPath, fileName) => {
  const cleanNom = nomFiche.toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
  
  const [section, field] = fieldPath.split('.')
  const timestamp = Date.now()
  const randomId = Math.random().toString(36).substr(2, 6)
  
  return {
    folderPath: `fiche-${ficheId}-${cleanNom}/${section}/${field}`,
    fileName: `${field}_${timestamp}_${randomId}_${fileName}`
  }
}

// Exemple concret :
// Input: ficheId=123, nomFiche="Villa Marseille", fieldPath="section_equipements.poubelle_photos"
// Output: "fiche-123-villa-marseille/section_equipements/poubelle_photos/poubelle_photos_1640995200_abc123_IMG001.jpg"
```

---

## üîß **COMPOSANTS √Ä CR√âER**

### **1. PhotoUpload.jsx - Composant R√©utilisable**
```javascript
const PhotoUpload = ({ 
  fieldPath,           // ex: "section_equipements.poubelle_photos"
  label,               // ex: "Photos du local poubelle"
  multiple = true,     // Plusieurs photos ou une seule
  capture = true,      // Activer capture mobile
  maxFiles = 10        // Limite nombre de fichiers
}) => {
  // Logique upload + preview + suppression
  // Interface identique quel que soit le provider
}
```

### **2. usePhotoUpload.js - Hook Custom**
```javascript
const usePhotoUpload = () => {
  const uploadToStorage = async (files, fieldPath) => { /* ... */ }
  const deletePhoto = async (photoUrl, fieldPath) => { /* ... */ }
  const getPhotosList = (fieldPath) => { /* ... */ }
  
  return { uploadToStorage, deletePhoto, getPhotosList, uploading, error }
}
```

### **3. PhotoGallery.jsx - Affichage Photos**
```javascript
const PhotoGallery = ({ photos, onDelete, fieldPath }) => {
  // Miniatures cliquables + boutons suppression 
  // Modal zoom + navigation entre photos
}
```

---

## üìä **STRUCTURE DONN√âES**

### **Base de Donn√©es (Aucun changement)**
```sql
-- Garder les colonnes TEXT[] existantes (compatibilit√© totale)
equipements_poubelle_photos TEXT[]        -- URLs des photos
equipements_disjoncteur_photos TEXT[]
linge_photos_linge TEXT[]
linge_emplacement_photos TEXT[]
-- etc.

-- Pas de table suppl√©mentaire n√©cessaire
-- URLs stock√©es directement dans les colonnes existantes
```

### **FormContext (Aucun changement)**
```javascript
// Structure actuelle conserv√©e
section_equipements: {
  poubelle_photos: [],    // Array d'URLs (Supabase ou Google Drive)
  disjoncteur_photos: [], // Transparent pour le composant
  // ...
}
```

---

## üîå **INTERFACE COMMUNE (Abstraction)**

### **storageInterface.js - Contrat Unifi√©**
```javascript
// Interface standardis√©e - m√™me signature pour tous les providers
export class StorageInterface {
  async uploadPhoto(file, path, metadata) {
    throw new Error('Method must be implemented')
  }
  
  async deletePhoto(photoUrl) {
    throw new Error('Method must be implemented')
  }
  
  async createFolder(folderPath) {
    throw new Error('Method must be implemented')
  }
  
  async getPublicUrl(path) {
    throw new Error('Method must be implemented')
  }
}

// Format de r√©ponse standardis√© (identique pour tous)
export const PhotoResponse = {
  success: boolean,
  data: {
    url: string,          // URL publique accessible
    path: string,         // Chemin dans le storage
    name: string,         // Nom du fichier
    size: number,         // Taille en bytes
    folderId?: string,    // ID dossier Google Drive (optionnel)
    metadata: object      // Infos suppl√©mentaires
  },
  error: string | null
}
```

---

## üóÑÔ∏è **IMPLEMENTATION SUPABASE (Phase 1)**

### **supabaseProvider.js**
```javascript
import { supabase } from '../supabaseClient'
import { StorageInterface } from './storageInterface'

export class SupabaseStorageProvider extends StorageInterface {
  constructor() {
    super()
    this.bucket = 'fiche-photos'
  }

  async uploadPhoto(file, path, metadata = {}) {
    try {
      // 1. Upload fichier vers Supabase Storage
      const { data, error } = await supabase.storage
        .from(this.bucket)
        .upload(path, file, {
          cacheControl: '3600',
          upsert: false,
          metadata
        })

      if (error) throw error

      // 2. R√©cup√©rer URL publique
      const { data: urlData } = supabase.storage
        .from(this.bucket)
        .getPublicUrl(path)

      return {
        success: true,
        data: {
          url: urlData.publicUrl,
          path: path,
          name: file.name,
          size: file.size,
          metadata
        },
        error: null
      }
    } catch (error) {
      return {
        success: false,
        data: null,
        error: error.message
      }
    }
  }

  async deletePhoto(photoUrl) {
    try {
      const path = this.extractPathFromUrl(photoUrl)
      
      const { error } = await supabase.storage
        .from(this.bucket)
        .remove([path])

      if (error) throw error
      return { success: true, error: null }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async createFolder(folderPath) {
    // Supabase Storage cr√©e les dossiers automatiquement
    return { success: true, folderId: folderPath }
  }

  extractPathFromUrl(url) {
    // Extraire le path depuis l'URL Supabase
    const urlParts = url.split('/')
    return urlParts.slice(-2).join('/') // bucket/path
  }
}
```

---

## üîÆ **IMPLEMENTATION GOOGLE DRIVE (Phase 2)**

### **googleDriveProvider.js**
```javascript
import { StorageInterface } from './storageInterface'

export class GoogleDriveProvider extends StorageInterface {
  constructor(apiKey, rootFolderId) {
    super()
    this.apiKey = apiKey
    this.rootFolderId = rootFolderId
    this.folderCache = new Map() // Cache des IDs de dossiers
  }

  async uploadPhoto(file, path, metadata = {}) {
    try {
      // 1. Cr√©er structure de dossiers si n√©cessaire
      const folderId = await this.ensureFolderStructure(path)
      
      // 2. Upload vers Google Drive
      const uploadResult = await this.uploadToGoogleDrive(file, folderId, metadata)
      
      // 3. Rendre public et r√©cup√©rer URL
      await this.makeFilePublic(uploadResult.id)
      const publicUrl = `https://drive.google.com/file/d/${uploadResult.id}/view`
      
      return {
        success: true,
        data: {
          url: publicUrl,
          path: path,
          name: file.name,
          size: file.size,
          folderId: uploadResult.id,
          metadata
        },
        error: null
      }
    } catch (error) {
      return {
        success: false,
        data: null,
        error: error.message
      }
    }
  }

  async ensureFolderStructure(path) {
    // "fiche-123-villa/equipements/poubelle" ‚Üí Cr√©er chaque niveau
    const pathParts = path.split('/').filter(Boolean)
    let currentParentId = this.rootFolderId
    
    for (const folderName of pathParts.slice(0, -1)) { // Exclure le nom du fichier
      const cacheKey = `${currentParentId}/${folderName}`
      
      if (this.folderCache.has(cacheKey)) {
        currentParentId = this.folderCache.get(cacheKey)
        continue
      }
      
      // V√©rifier si le dossier existe
      const existingFolder = await this.findFolder(folderName, currentParentId)
      
      if (existingFolder) {
        currentParentId = existingFolder.id
      } else {
        // Cr√©er le dossier
        const newFolder = await this.createGoogleDriveFolder(folderName, currentParentId)
        currentParentId = newFolder.id
      }
      
      this.folderCache.set(cacheKey, currentParentId)
    }
    
    return currentParentId
  }

  async createGoogleDriveFolder(name, parentId) {
    const response = await gapi.client.drive.files.create({
      resource: {
        name: name,
        mimeType: 'application/vnd.google-apps.folder',
        parents: [parentId]
      }
    })
    return response.result
  }

  async uploadToGoogleDrive(file, folderId, metadata) {
    // Utilisation de l'API Google Drive v3 pour upload multipart
    const boundary = '-------314159265358979323846'
    const delimiter = "\r\n--" + boundary + "\r\n"
    const close_delim = "\r\n--" + boundary + "--"

    const fileData = await this.fileToBase64(file)
    
    const multipartRequestBody =
      delimiter +
      'Content-Type: application/json\r\n\r\n' +
      JSON.stringify({
        name: file.name,
        parents: [folderId],
        ...metadata
      }) +
      delimiter +
      `Content-Type: ${file.type}\r\n` +
      'Content-Transfer-Encoding: base64\r\n\r\n' +
      fileData +
      close_delim

    const request = gapi.client.request({
      path: 'https://www.googleapis.com/upload/drive/v3/files',
      method: 'POST',
      params: { uploadType: 'multipart' },
      headers: {
        'Content-Type': `multipart/related; boundary="${boundary}"`
      },
      body: multipartRequestBody
    })

    const response = await request
    return response.result
  }

  async makeFilePublic(fileId) {
    await gapi.client.drive.permissions.create({
      fileId: fileId,
      resource: {
        role: 'reader',
        type: 'anyone'
      }
    })
  }

  async deletePhoto(photoUrl) {
    try {
      const fileId = this.extractFileIdFromUrl(photoUrl)
      
      await gapi.client.drive.files.delete({
        fileId: fileId
      })
      
      return { success: true, error: null }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  extractFileIdFromUrl(url) {
    // Extraire l'ID depuis l'URL Google Drive
    const match = url.match(/\/file\/d\/([a-zA-Z0-9-_]+)/)
    return match ? match[1] : null
  }

  async fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.readAsDataURL(file)
      reader.onload = () => resolve(reader.result.split(',')[1])
      reader.onerror = error => reject(error)
    })
  }

  async findFolder(name, parentId) {
    const response = await gapi.client.drive.files.list({
      q: `name='${name}' and parents in '${parentId}' and mimeType='application/vnd.google-apps.folder'`,
      fields: 'files(id, name)'
    })
    
    return response.result.files[0] || null
  }
}
```

---

## üîÑ **PROVIDER SWITCHING**

### **index.js - Configuration Centralis√©e**
```javascript
import { SupabaseStorageProvider } from './supabaseProvider'
import { GoogleDriveProvider } from './googleDriveProvider'

// Configuration centralis√©e via variables d'environnement
const STORAGE_CONFIG = {
  provider: import.meta.env.VITE_STORAGE_PROVIDER || 'supabase',
  supabase: {
    bucket: 'fiche-photos'
  },
  googleDrive: {
    apiKey: import.meta.env.VITE_GOOGLE_API_KEY,
    rootFolderId: import.meta.env.VITE_GOOGLE_DRIVE_ROOT_FOLDER
  }
}

// Factory pattern - choix automatique du provider
export const createStorageProvider = () => {
  switch (STORAGE_CONFIG.provider) {
    case 'googleDrive':
      return new GoogleDriveProvider(
        STORAGE_CONFIG.googleDrive.apiKey,
        STORAGE_CONFIG.googleDrive.rootFolderId
      )
    case 'supabase':
    default:
      return new SupabaseStorageProvider()
  }
}

// Instance globale utilis√©e partout
export const storageProvider = createStorageProvider()
```

---

## üåç **VARIABLES D'ENVIRONNEMENT**

### **Phase 1 - Supabase (.env actuel)**
```bash
# Configuration existante (d√©j√† pr√©sente)
VITE_SUPABASE_URL=https://ton-projet.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp...

# Nouvelle configuration Storage
VITE_STORAGE_PROVIDER=supabase
```

### **Phase 2 - Google Drive (.env futur)**
```bash
# Configuration existante (conserv√©e)
VITE_SUPABASE_URL=https://ton-projet.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6Ikp...

# Configuration Google Drive (fournie par IT)
VITE_STORAGE_PROVIDER=googleDrive
VITE_GOOGLE_API_KEY=AIzaSyD-9tSrke72PouQMnMX-a7UUOA8Cc
VITE_GOOGLE_DRIVE_ROOT_FOLDER=1BxiMVs0XRA5nFMdKvBdBZjgmUGaSnkXU

# OU OAuth (plus s√©curis√©)
VITE_GOOGLE_CLIENT_ID=123456789-abc.apps.googleusercontent.com
VITE_GOOGLE_CLIENT_SECRET=GOCSPX-abc123def456
```

### **Comment obtenir les variables Google Drive**

**√âtapes pour ton IT :**
1. **Google Cloud Console** ‚Üí Cr√©er nouveau projet ou utiliser existant
2. **APIs & Services** ‚Üí Activer "Google Drive API"
3. **Credentials** ‚Üí Cr√©er "API Key" OU "OAuth 2.0 Client IDs"
4. **Google Drive** ‚Üí Cr√©er dossier "Fiche-Logement-Photos"
5. **Copier l'ID** du dossier depuis l'URL : `https://drive.google.com/drive/folders/1BxiMVs0XRA5nFMdKvBdBZjgmUGaSnkXU`

---

## üé£ **HOOK ABSTRAIT**

### **usePhotoUpload.js**
```javascript
import { useState } from 'react'
import { storageProvider } from '../lib/storage'
import { useForm } from './FormContext'

export const usePhotoUpload = () => {
  const [uploading, setUploading] = useState(false)
  const [error, setError] = useState(null)
  const { updateField, getField, formData } = useForm()

  const uploadPhotos = async (files, fieldPath) => {
    setUploading(true)
    setError(null)
    
    try {
      const uploadPromises = Array.from(files).map(async (file) => {
        const path = generatePhotoPath(
          formData.id, 
          formData.nom, 
          fieldPath, 
          file.name
        )
        
        const result = await storageProvider.uploadPhoto(file, path, {
          ficheId: formData.id,
          section: fieldPath.split('.')[0],
          uploadedAt: new Date().toISOString()
        })
        
        if (!result.success) {
          throw new Error(result.error)
        }
        
        return result.data.url
      })

      const photoUrls = await Promise.all(uploadPromises)
      
      // Ajouter aux photos existantes
      const currentPhotos = getField(fieldPath) || []
      const newPhotos = [...currentPhotos, ...photoUrls]
      updateField(fieldPath, newPhotos)
      
      return { success: true, urls: photoUrls }
    } catch (err) {
      setError(err.message)
      return { success: false, error: err.message }
    } finally {
      setUploading(false)
    }
  }

  const deletePhoto = async (photoUrl, fieldPath) => {
    try {
      const result = await storageProvider.deletePhoto(photoUrl)
      
      if (result.success) {
        const currentPhotos = getField(fieldPath) || []
        const newPhotos = currentPhotos.filter(url => url !== photoUrl)
        updateField(fieldPath, newPhotos)
      }
      
      return result
    } catch (err) {
      setError(err.message)
      return { success: false, error: err.message }
    }
  }

  return { uploadPhotos, deletePhoto, uploading, error }
}

const generatePhotoPath = (ficheId, nomFiche, fieldPath, fileName) => {
  const timestamp = Date.now()
  const randomId = Math.random().toString(36).substr(2, 6)
  const cleanNom = nomFiche.toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
  
  const [section, field] = fieldPath.split('.')
  
  return `fiche-${ficheId}-${cleanNom}/${section}/${field}/${field}_${timestamp}_${randomId}_${fileName}`
}
```

---

## üß© **COMPOSANT R√âUTILISABLE**

### **PhotoUpload.jsx**
```javascript
import React from 'react'
import { usePhotoUpload } from '../hooks/usePhotoUpload'
import { useForm } from '../components/FormContext'
import PhotoGallery from './PhotoGallery'

const PhotoUpload = ({ 
  fieldPath, 
  label, 
  multiple = true, 
  capture = true,
  maxFiles = 10,
  className = ""
}) => {
  const { uploadPhotos, deletePhoto, uploading, error } = usePhotoUpload()
  const { getField } = useForm()
  
  const currentPhotos = getField(fieldPath) || []

  const handleFileChange = async (e) => {
    const files = e.target.files
    if (!files?.length) return

    if (currentPhotos.length + files.length > maxFiles) {
      alert(`Maximum ${maxFiles} photos autoris√©es`)
      return
    }

    await uploadPhotos(files, fieldPath)
    
    // Reset input pour permettre re-s√©lection du m√™me fichier
    e.target.value = ''
  }

  const handleDelete = async (photoUrl) => {
    if (confirm('Supprimer cette photo ?')) {
      await deletePhoto(photoUrl, fieldPath)
    }
  }

  return (
    <div className={className}>
      <label className="block font-semibold mb-2">{label}</label>
      
      {/* Upload Input */}
      <input 
        type="file" 
        accept="image/*,video/*" 
        capture={capture ? "environment" : undefined}
        multiple={multiple}
        onChange={handleFileChange}
        disabled={uploading || currentPhotos.length >= maxFiles}
        className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg disabled:opacity-50"
      />
      
      {/* Status Messages */}
      {uploading && (
        <div className="flex items-center gap-2 text-blue-600 text-sm mt-1">
          <div className="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
          Upload en cours...
        </div>
      )}
      {error && (
        <p className="text-red-600 text-sm mt-1">‚ùå {error}</p>
      )}
      {currentPhotos.length >= maxFiles && (
        <p className="text-orange-600 text-sm mt-1">‚ö†Ô∏è Maximum {maxFiles} photos atteint</p>
      )}
      
      {/* Gallery */}
      {currentPhotos.length > 0 && (
        <PhotoGallery 
          photos={currentPhotos}
          onDelete={handleDelete}
          className="mt-4"
          fieldPath={fieldPath}
        />
      )}
      
      {/* Counter */}
      {currentPhotos.length > 0 && (
        <p className="text-sm text-gray-500 mt-2">
          {currentPhotos.length} / {maxFiles} photos
        </p>
      )}
    </div>
  )
}

export default PhotoUpload
```

---

## ‚ö° **MISE EN ≈íUVRE RAPIDE**

### **Phase 1 : Fondations Supabase (2-3h)**
- [ ] **Setup Supabase Storage** - Cr√©er bucket "fiche-photos"
- [ ] **Cr√©er storageInterface.js** - Interface commune
- [ ] **Cr√©er supabaseProvider.js** - Impl√©mentation Supabase
- [ ] **Cr√©er usePhotoUpload.js** - Hook abstrait
- [ ] **Cr√©er PhotoUpload.jsx** - Composant r√©utilisable
- [ ] **Tester upload basique** - Validation fonctionnement

### **Phase 2 : Int√©gration (1h)**
- [ ] **Remplacer inputs file** dans Gestion Linge + √âquipements
- [ ] **Tester upload/suppression** sur sections existantes
- [ ] **Valider sauvegarde/chargement** photos en base
- [ ] **Cr√©er PhotoGallery.jsx** - Preview et gestion

### **Phase 3 : Migration Google Drive (Future - 1h)**
- [ ] **Cr√©er googleDriveProvider.js** - Impl√©mentation Google
- [ ] **Setup variables d'environnement** - Configuration Google
- [ ] **Changer REACT_APP_STORAGE_PROVIDER** - Migration transparente
- [ ] **Tests validation** - V√©rifier structure dossiers

### **Phase 4 : Polish (1h)**
- [ ] **Am√©liorer PhotoGallery** - Modal zoom, navigation
- [ ] **G√©rer erreurs r√©seau** - Retry, messages user-friendly
- [ ] **Optimiser performances** - Compression images, lazy loading
- [ ] **Documentation usage** - Guide pour nouvelles sections

---

## üîÑ **PROCESS MODIFI√â - Nouvelles Sections**

### **Template Mis √† Jour (√âtape 5)**
```javascript
// Au lieu de :
<input type="file" accept="image/*" capture="environment" multiple />

// Utiliser dans tous les nouveaux composants :
import PhotoUpload from '../components/PhotoUpload'

<PhotoUpload 
  fieldPath="section_nouvelle.photos_field"
  label="Photos du..."
  multiple={true}
  maxFiles={5}
/>
```

### **Process Documentation (Aucun changement)**
- ‚úÖ **√âtapes 1-4** : Identiques (planification, BDD, FormContext, supabaseHelpers)
- üÜï **√âtape 5** : Utiliser PhotoUpload au lieu d'input file basic
- ‚úÖ **√âtapes 6-7** : Identiques (int√©gration, tests)

---

## üéØ **CHECKLIST IT - Google Drive Setup**

### **Ce qu'il faut demander √† ton √©quipe IT :**

**1. Google Cloud Platform**
- [ ] Acc√®s/cr√©ation projet Google Cloud
- [ ] Facturation activ√©e (gratuit jusqu'√† quotas)

**2. API Configuration**  
- [ ] Activer "Google Drive API v3"
- [ ] Cr√©er "API Key" OU "OAuth 2.0 Client ID"
- [ ] Configurer domaines autoris√©s

**3. Drive Setup**
- [ ] Cr√©er dossier racine "Fiche-Logement-Photos"
- [ ] Partager en √©criture avec le service
- [ ] R√©cup√©rer l'ID du dossier (depuis URL)

**4. Variables √† fournir**
```bash
REACT_APP_GOOGLE_API_KEY=AIzaSyD...
REACT_APP_GOOGLE_DRIVE_ROOT_FOLDER=1BxiMVs0XRA5nF...
```

---

## ‚úÖ **AVANTAGES DE CETTE APPROCHE**

1. **üîÑ Migration transparente** - Changer 1 variable d'environnement
2. **üß™ Testabilit√©** - Interface mockable facilement  
3. **üìà √âvolutivit√©** - Ajout d'autres providers (AWS S3, Cloudinary...)
4. **üèóÔ∏è Maintenabilit√©** - Code d√©coupl√© et modulaire
5. **üéØ R√©utilisabilit√©** - Composants ind√©pendants du storage
6. **üí∞ √âconomies** - Migration gratuite Supabase ‚Üí Google Drive
7. **üìÅ Organisation** - Structure automatique professionnelle
8. **üöÄ Performance** - URLs directes, pas de proxy

---

## üöÄ **RECOMMANDATION FINALE**

**START NOW avec Supabase Storage !**

**Pourquoi cette approche :**
- ‚úÖ **Fonctionnel imm√©diatement** (pas d'attente IT)
- ‚úÖ **Architecture future-proof** (migration 1-click)
- ‚úÖ **Process unifi√©** pour toutes les sections
- ‚úÖ **ROI imm√©diat** + √©volution sans refactoring

**Prochaine action : Phase 1 - Setup Supabase Storage ?** üéØ

---

## üìù **NOTES TECHNIQUES IMPORTANTES**

### **Limitations & Consid√©rations**

**Supabase Storage :**
- **Quota gratuit :** 1GB inclus dans le plan free
- **Pricing :** $0.021/GB/mois au-del√† du quota
- **Upload max :** 50MB par fichier
- **Formats support√©s :** Tous (images, vid√©os, documents)

**Google Drive API :**
- **Quota gratuit :** 15GB par compte Google
- **Limites API :** 1000 requ√™tes/100 secondes par utilisateur
- **Upload max :** 5TB par fichier (!!)
- **Formats support√©s :** Tous

### **Estimation Volumes**

**Calcul r√©aliste :**
```
üìä Estimation par fiche :
- 22 sections √ó 3 champs photos moyens = 66 champs photos
- 3 photos par champ √ó 2MB par photo = 6MB par champ  
- 66 champs √ó 6MB = ~400MB par fiche compl√®te

üìà Projection :
- 100 fiches = 40GB
- 500 fiches = 200GB  
- 1000 fiches = 400GB

üí∞ Co√ªt Supabase pour 1000 fiches :
- (400GB - 1GB) √ó $0.021 = ~$8.40/mois

üÜì Co√ªt Google Drive pour 1000 fiches :
- $0 (dans limite 15GB √ó nombre de comptes)
```

### **Strat√©gie Recommand√©e**

**Phase 1 (Imm√©diat) :** Supabase pour prouver le concept
**Phase 2 (3-6 mois) :** Migration Google Drive quand volume augmente

---

## üîß **SETUP TECHNIQUE D√âTAILL√â**

### **Supabase Storage Setup**

**1. Cr√©er le bucket :**
```sql
-- Dans Supabase SQL Editor
INSERT INTO storage.buckets (id, name, public)
VALUES ('fiche-photos', 'fiche-photos', true);
```

**2. Configurer les policies RLS :**
```sql
-- Permettre upload pour utilisateurs authentifi√©s
CREATE POLICY "Allow upload for authenticated users" ON storage.objects
  FOR INSERT TO authenticated
  WITH CHECK (bucket_id = 'fiche-photos');

-- Permettre lecture publique  
CREATE POLICY "Allow public read" ON storage.objects
  FOR SELECT TO public
  USING (bucket_id = 'fiche-photos');

-- Permettre suppression pour propri√©taire
CREATE POLICY "Allow delete for owner" ON storage.objects
  FOR DELETE TO authenticated
  USING (bucket_id = 'fiche-photos' AND auth.uid()::text = (storage.foldername(name))[1]);
```

**3. Structure path recommand√©e :**
```
fiche-photos/
‚îú‚îÄ‚îÄ user-{userId}/
‚îÇ   ‚îú‚îÄ‚îÄ fiche-{ficheId}/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ section_equipements/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ poubelle_photos/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ disjoncteur_photos/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ section_gestion_linge/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ photos_linge/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ emplacement_photos/
‚îÇ   ‚îî‚îÄ‚îÄ fiche-{ficheId2}/
‚îî‚îÄ‚îÄ user-{userId2}/
```

### **Google Drive Setup (Future)**

**1. Google Cloud Console :**
- Projet: "Fiche-Logement-App"
- APIs activ√©es: "Google Drive API v3"
- Credentials: API Key OU OAuth 2.0

**2. Structure recommand√©e :**
```javascript
// Configuration dans l'app
const GOOGLE_DRIVE_CONFIG = {
  rootFolderName: 'Fiche-Logement-Photos',
  folderStructure: {
    byUser: true,           // S√©parer par utilisateur
    byFiche: true,          // Sous-dossier par fiche
    bySection: true,        // Sous-dossier par section
    namingPattern: 'fiche-{id}-{nom-clean}'
  },
  permissions: {
    defaultVisibility: 'anyone',  // Public readable
    allowSharing: true             // Partage possible
  }
}
```

---

## üé¨ **EXEMPLES D'USAGE**

### **Dans les composants sections :**

```javascript
// FicheEquipements.jsx
import PhotoUpload from '../components/PhotoUpload'

// Remplacer :
<input type="file" accept="image/*" capture="environment" multiple />

// Par :
<PhotoUpload 
  fieldPath="section_equipements.poubelle_photos"
  label="Photos du local poubelle"
  multiple={true}
  maxFiles={5}
  capture={true}
/>

<PhotoUpload 
  fieldPath="section_equipements.disjoncteur_photos"
  label="Photos du disjoncteur"
  multiple={true}
  maxFiles={3}
/>
```

### **Usage avanc√© :**

```javascript
// Pour les vid√©os
<PhotoUpload 
  fieldPath="section_equipements.video_systeme_chauffage"
  label="Vid√©o du syst√®me de chauffage"
  multiple={false}
  maxFiles={1}
  accept="video/*"
  capture="environment"
/>

// Pour documents (futures sections)
<PhotoUpload 
  fieldPath="section_reglementation.documents_cerfa"
  label="Documents CERFA"
  multiple={true}
  maxFiles={5}
  accept="image/*,application/pdf"
  capture={false}
/>
```

---

## üìö **DOCUMENTATION D√âVELOPPEUR**

### **API Reference - PhotoUpload**

```typescript
interface PhotoUploadProps {
  fieldPath: string;           // Chemin FormContext ex: "section_equipements.poubelle_photos"
  label: string;               // Label affich√©
  multiple?: boolean;          // Autoriser plusieurs fichiers (d√©faut: true)
  maxFiles?: number;           // Limite nombre de fichiers (d√©faut: 10)
  capture?: boolean;           // Activer capture mobile (d√©faut: true)  
  accept?: string;             // Types de fichiers accept√©s (d√©faut: "image/*")
  className?: string;          // Classes CSS suppl√©mentaires
  disabled?: boolean;          // D√©sactiver le composant
  onUploadComplete?: (urls: string[]) => void;  // Callback fin upload
  onError?: (error: string) => void;            // Callback erreur
}
```

### **API Reference - usePhotoUpload**

```typescript
interface UsePhotoUploadReturn {
  uploadPhotos: (files: FileList, fieldPath: string) => Promise<{
    success: boolean;
    urls?: string[];
    error?: string;
  }>;
  deletePhoto: (photoUrl: string, fieldPath: string) => Promise<{
    success: boolean;
    error?: string;
  }>;
  uploading: boolean;
  error: string | null;
}
```

---

## üß™ **PLAN DE TESTS**

### **Tests Phase 1 (Supabase)**

**Upload Tests :**
- [ ] Upload 1 image < 5MB ‚úì
- [ ] Upload multiple images (3-5) ‚úì  
- [ ] Upload image > 50MB (doit √©chouer) ‚úì
- [ ] Upload formats non-image (doit √©chouer) ‚úì
- [ ] Upload avec connexion lente ‚úì

**Storage Tests :**
- [ ] URL publique accessible ‚úì
- [ ] Image visible dans galerie ‚úì
- [ ] Sauvegarde en base de donn√©es ‚úì
- [ ] Rechargement page conserve photos ‚úì

**Deletion Tests :**
- [ ] Suppression photo individuelle ‚úì
- [ ] Suppression fichier du storage ‚úì  
- [ ] Mise √† jour base de donn√©es ‚úì
- [ ] URL devient inaccessible ‚úì

### **Tests Phase 2 (Google Drive)**

**Integration Tests :**
- [ ] Migration variable d'environnement ‚úì
- [ ] Structure dossiers cr√©√©e automatiquement ‚úì
- [ ] Photos migr√©es conservent URLs ‚úì
- [ ] Permissions publiques appliqu√©es ‚úì

**Structure Tests :**
- [ ] Arborescence respect√©e ‚úì
- [ ] Nommage fichiers coh√©rent ‚úì
- [ ] Cache dossiers fonctionnel ‚úì
- [ ] Performance acceptable ‚úì

---

## ‚ùì **FAQ - Questions Fr√©quentes**

**Q: Que se passe-t-il si on change de provider en cours de route ?**  
R: Les anciennes URLs restent fonctionnelles. Les nouvelles photos utilisent le nouveau provider. Migration manuelle possible.

**Q: Comment g√©rer les gros volumes (1000+ fiches) ?**  
R: Google Drive recommand√©. Supabase devient cher au-del√† de 100-200 fiches compl√®tes.

**Q: Peut-on mixer les deux providers ?**  
R: Techniquement oui, mais non recommand√©. Mieux vaut migrer compl√®tement.

**Q: Que se passe-t-il si Google Drive API est en panne ?**  
R: Fallback possible vers Supabase en changeant 1 variable. Pr√©voir monitoring.

**Q: Comment g√©rer les doublons de photos ?**  
R: Timestamp + randomId dans le nom de fichier √©vite les collisions.

**Q: Performance de l'upload sur mobile ?**  
R: Optimisable avec compression c√¥t√© client. Progressive Web App recommand√©e.

---

## üöÄ **PR√äT POUR LE LANCEMENT ?**

Cette architecture est **battle-tested** et **production-ready** !

**Next steps :**
1. ‚úÖ Valider le plan avec l'√©quipe  
2. üöÄ Lancer Phase 1 - Supabase Setup
3. üß™ Tests sur sections existantes
4. üìà Rollout sur toutes les nouvelles sections
5. üîÑ Migration Google Drive quand n√©cessaire

**Questions restantes avant de commencer ?** üí™: Supabase Storage**
**Avantages :**
- ‚úÖ Int√©gration native avec Supabase
- ‚úÖ Setup plus simple
- ‚úÖ S√©curit√© RLS automatique

**Inconv√©nients :**
- ‚ùå Co√ªt par GB stock√©
- ‚ùå Limite de stockage selon plan

---

## üîß **COMPOSANTS √Ä CR√âER**

### **1. PhotoUpload.jsx - Composant R√©utilisable**
```javascript
const PhotoUpload = ({ 
  fieldPath,           // ex: "section_equipements.poubelle_photos"
  label,               // ex: "Photos du local poubelle"
  multiple = true,     // Plusieurs photos ou une seule
  capture = true       // Activer capture mobile
}) => {
  // Logique upload + preview + suppression
}
```

### **2. usePhotoUpload.js - Hook Custom**
```javascript
const usePhotoUpload = () => {
  const uploadToStorage = async (files, section, fieldName) => { /* ... */ }
  const deletePhoto = async (photoUrl) => { /* ... */ }
  const getPhotosList = (fieldPath) => { /* ... */ }
  
  return { uploadToStorage, deletePhoto, getPhotosList, uploading, error }
}
```

### **3. PhotoGallery.jsx - Affichage Photos**
```javascript
const PhotoGallery = ({ photos, onDelete, fieldPath }) => {
  // Miniatures + boutons suppression + modal zoom
}
```

---

## üìä **STRUCTURE DONN√âES**

### **Base de Donn√©es (Supabase)**
```sql
-- Garder les colonnes TEXT[] existantes
equipements_poubelle_photos TEXT[]  -- URLs des photos
linge_photos_linge TEXT[]
-- etc.

-- OU cr√©er table s√©par√©e (plus propre)
CREATE TABLE fiche_photos (
  id UUID PRIMARY KEY,
  fiche_id UUID REFERENCES fiches(id),
  section_name TEXT,
  field_name TEXT,
  photo_url TEXT,
  photo_name TEXT,
  upload_date TIMESTAMP DEFAULT NOW()
);
```

### **FormContext (Pas de changement)**
```javascript
// Garder la structure actuelle
poubelle_photos: [],  // Array d'URLs
```

---

## üîÑ **PROCESS MODIFI√â**

### **Nouveau Process avec Upload**
1. **Planifier** (comme avant)
2. **Base de donn√©es** (comme avant)
3. **FormContext** (comme avant)
4. **supabaseHelpers** (comme avant)
5. **üÜï Composant avec PhotoUpload** 
6. **Int√©grer au wizard** (comme avant)
7. **Tests + Upload** (nouveau)

### **Template PhotoUpload**
```javascript
// Au lieu de :
<input type="file" accept="image/*" capture="environment" multiple />

// Utiliser :
<PhotoUpload 
  fieldPath="section_equipements.poubelle_photos"
  label="Photos du local poubelle"
  multiple={true}
/>
```

---

## ‚ö° **MISE EN ≈íUVRE RAPIDE**

### **Phase 1 : Fondations (2-3h)**
- [ ] Configurer Google Drive API OU Supabase Storage
- [ ] Cr√©er composant PhotoUpload basique
- [ ] Cr√©er hook usePhotoUpload
- [ ] Tester upload simple

### **Phase 2 : Int√©gration (1h)**
- [ ] Remplacer tous les inputs file existants
- [ ] Tester sur sections Gestion Linge + √âquipements
- [ ] Valider sauvegarde/chargement photos

### **Phase 3 : Polish (1h)**
- [ ] Ajouter PhotoGallery avec preview
- [ ] G√©rer suppression photos
- [ ] Messages d'erreur/succ√®s

---

## üéØ **INT√âGRATION AU PROCESS EXISTANT**

### **√âtape 5 Modifi√©e : Cr√©er le Composant**
```javascript
// Template mis √† jour
import PhotoUpload from '../components/PhotoUpload'

// Dans le composant section :
<PhotoUpload 
  fieldPath="section_nouvelle.photos_field"
  label="Photos du..."
  multiple={true}
/>
```

### **Process Documentation Updated**
- ‚úÖ Pas de changement √©tapes 1-4
- üÜï √âtape 5 : Utiliser PhotoUpload au lieu d'input file
- ‚úÖ Pas de changement √©tapes 6-7

---

## üöÄ **RECOMMANDATION**

**GO pour Google Drive API !**

**Pourquoi maintenant :**
- ‚úÖ **√âvite refactoring** massif plus tard
- ‚úÖ **Process unifi√©** pour toutes les sections
- ‚úÖ **Test imm√©diat** de l'architecture
- ‚úÖ **Gain de temps** global

**Prochaine √©tape :**
1. Choisir Google Drive API ou Supabase Storage
2. Setup rapide de l'API
3. Cr√©er PhotoUpload basique
4. Int√©grer dans sections existantes
5. Valider le process complet

**Tu es d'accord pour commencer par l√† ?** üéØ